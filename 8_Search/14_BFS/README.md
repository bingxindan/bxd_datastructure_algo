# 什么是“搜索”算法？

*   算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。
*   图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。
*   图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。
*   深度优先搜索算法和广度优先搜索算法，既可以用在无向图，也可以用在有向图上。

# 广度优先搜索（BFS）

*   广度优先搜索（Breadth-First-Search），我们平常都简称 BFS。
*   它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。
*   广度优先搜索的时间复杂度是多少呢？&#x20;
    *   最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。
    *   每个顶点都要进出一遍队列，每个边也都会被访问一次，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。
    *   对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。
*   广度优先搜索的空间复杂度是多少呢？

    *   广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。
    *   这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。

# 深度优先搜索（DFS）

*   深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。
*   深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。
*   深度优先搜索的时间复杂度是多少呢？
    *   每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。
*   深度优先搜索的空间复杂度是多少呢？
    *   消耗内存主要是 visited、prev 数组和递归调用栈。
    *   visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。

# 如何找出社交网络中某个用户的三度好友关系？

*   用图的广度优先搜索算法来解决，因为广度优先搜索是层层往外推进的。
*   首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 2 的顶点，也就是二度好友关系，以及与用户距离的边数为 3 的顶点，也就是三度好友关系。

