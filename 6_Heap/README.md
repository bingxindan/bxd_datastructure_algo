# “堆”（Heap）

*   堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。
*   堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。
*   堆排和快排的，时间复杂度都是 O(nlogn)，甚至堆排序比快速排序的时间复杂度还要稳定。
*   在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？

# 如何理解“堆”？

*   堆是一种特殊的树。
*   什么样的树才是堆？

    *   堆是一个完全二叉树；
    *   堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
    *   每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。
    *   每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。

# 如何实现一个堆？

*   要实现一个堆，我们先要知道，堆都支持哪些操作以及如何存储一个堆。
*   完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。
*   数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点。

往堆中插入一个元素

*   往堆中插入一个元素后，我们需要继续满足堆的两个特性。
*   重新满足堆的特性的过程，叫做堆化（heapify）。
*   堆化实际上有两种，从下往上和从上往下。这里我先讲从下往上的堆化方法。
*   堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。
