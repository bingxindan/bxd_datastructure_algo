> 散列、哈希，都叫Hash表。
> 散列算法、哈希算法，都叫Hash算法

# 定义

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。

# 设计Hash算法规则：

*   从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
*   对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
*   散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
*   哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

# Hash算法应用

*   应用一：安全加密

    *   最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA（Secure Hash Algorithm，安全散列算法）。
    *   DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。
    *   有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。
    *   哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。
    *   一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。
    *   SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。
*   应用二：唯一标识
*   应用三：数据校验

    *   当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。
*   应用四：散列函数

    *   散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中
*   Hash算法核心就是将数据均匀的分布在固定个数的槽中，使每个槽的数量接近相同
*   应用五：负载均衡

    *   负载均衡算法有很多，比如轮询、随机、加权轮询等。
    *   那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。

        *   通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。
*   应用六：数据分片

    *   如何统计“搜索关键词”出现的次数？

        *   假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？
        *   这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。
        *   我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。

            *   为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。
            *   哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。这里的处理过程也是 MapReduce 的基本设计思想。
    *   如何快速判断图片是否在图库中？

        *   对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。
        *   判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。
        *   估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。

            *   散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。
            *   通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。
            *   文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。
            *   假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB\*0.75/152）张图片构建散列表。
            *   如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。
            *   针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。
*   应用七：分布式存储

    *   为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。
    *   借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。
    *   如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。

        *   原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。
        *   所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。
        *   我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，一致性哈希算法就要登场了。

# 一致性哈希算法

*   假设我们有 k 个机器，数据的哈希值的范围是\[0, MAX]。
*   将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。
*   当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。
*   既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。

